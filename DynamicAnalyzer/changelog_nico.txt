Week1:
- Introduction and getting to know the project 
- find out why JUnit Tests fail
- fixed a bug where end-to-end test passed because no compiled binary was present, and failed
	if an outdated binary was present

Week2:
- ClassCompile written: Compile end-to-end tests automatically before testrun
- Output folder now configurable via "-d desiredDir" for both the JUnit test and main method / run configurations
- Fixed bug that for some IllegalFlowExcpetion, even though no involved variable was given, the test still passed
- wrote readme.md with setup instructions, code overview and most important command line commands
- some testclasses need to be rewritten (about 10): Some are incomplete, some do not provide the desired information leak, some are empty, some miss involved variables
-- added involvedVars to "ArithmeticExpressionsFail"
-- Rewrote ArrayRef: Split up in two files (*Fail, *Success), made sure desired information leak is present/not present
-- Fixed IfStmt test: Split it up, supplied illegal flow in *Fail, supplied appropriate variable.
- documented which tests fail, and why. also fixed some tests.


-- Todo: write external classes test using hand-instrumented external class. check and fix other tests.

Week 3:
	
Questions:
- what are objectmac.actualArgumentsLevel
- SimpleSwitchStmtFail: Should throw IllegalFlowEx, right?!
- SimpleSwitchStmtFail: What if we set argument in first method to 2? Can DA possibly
  catch illegal flow?!

Bugs:
- See ImplicitFlow{2, 3}
- See SystemOut1 and SystemOut2
- SwitchStmtFail{1, 2}

Notes:
- check if illegal flow (via local-sec-value > localPC) is contained in
	setLevelOfLocal method. I find this confusing, and not adhering to
	the seperation of concerns -> Split?
- global PC, only one, propagated down, reset after
	method is done
- local PC, implemented as a stack, used to different-
	iate between different ifs