<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>JGS-check</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="Description" lang="en" content="">
    <meta name="author" content="Luminous Fennell">
    <meta name="robots" content="index, follow">

    <!-- icons -->

    <!-- TODO: add some icons -->
    <!-- <link rel="apple-touch-icon" href="assets/img/apple-touch-icon.png"> -->
    <!-- <link rel="shortcut icon" href="favicon.ico"> -->

    <!-- Override CSS file - add your own CSS rules -->
    <link rel="stylesheet" href="assets/css/styles.css">
    <link rel="stylesheet" href="assets/css/prism.css">
    <script type="text/javascript" src="assets/js/prism.js"></script>
  </head>

<body>
  <div class="container">
    <div class="header">
      <h1 class="header-heading">JGS-check</h1>
    </div>
    <!-- <div class="nav-bar"> -->
    <!--    -->
    <!--   <ul class="nav"> -->
    <!-- 	 -->
    <!-- 	<li><a href="index.html">Overview</a></li> -->
    <!-- 	 -->
    <!--   </ul> -->
    <!--    -->
    <!-- </div> -->
    <div class="content">
      <div class="main">
	<h1 id="abstract">Abstract</h1>
<p>JGS-check is the accompanying artifact to &quot;LJGS: Gradual Security Types for Object-Oriented Languages&quot;. LJGS is a Java-like language with gradual security typing. It features a constraint based information flow type system that includes a type dynamic and type casts. Dynamically typed fragments are liberally accepted by the type checker and rely on run-time enforcement for security.</p>
<p>JGS-check is a type checker for the subset of Java that corresponds to the calculus presented in the paper and that implements the constraint generation and satisfiability checks of LJGS' type system. It's purpose is to illustrate and substantiate the behavior of our gradual security type system. It takes a directory of Java source code as input and reports methods that violate the typing rules. JGS-check is merely a type checker and does <em>not</em> implement code generation.</p>
<p>The submission archive includes the compiled type checker, the code of the example section (Section 2) as well additional examples and testcases that did not fit into the paper. The user should also be able to check custom code as long as it corresponds the subset of Java that is covered by LJGS.</p>
<p>The source code of JGS-check is available at <a href="https://github.com/luminousfennell/gradual-java/tree/master/GradualConstraints">github</a>.</p>
<h1 id="setup">Setup</h1>
<p>The directory <code>JGS-check-ecoop2016</code> contains a VirtualBox VM that has JGS-check installed. After starting the VM, open the folder <code>ecoop2016-ae-submission</code> and press <code>&lt;F4&gt;</code> to open a terminal in it. The tool is run by exectuing <code>make</code>. (cf <a href="#running-the-provided-examples">Running the provided examples</a>).</p>
<h1 id="check-procedure">Check procedure</h1>
<p>In a first phase JGS-check first checks the class hierarchy: The signature of an overriding method <code>m1</code> should always <em>refine</em> the signature of the &quot;super-&quot;method <code>m2</code>. That is, <code>m1</code>'s signatures has to be more restrictive than that <code>m2</code>. JGS-check checks each overriding method of the class hierarchy, printing an error message when appropriate.</p>
<p>The second phase generates constraints and effects for method bodies and checks two properties:</p>
<ol type="1">
<li><p>Satisfiability of the generated constraints.</p></li>
<li><p>If the generated constraints and effects refine the constraints and effects given in the method signature. This check is similar to the check between overriding- and super-method in the hierarchy check of the first phase.</p></li>
</ol>
<p>Each method of the sourcetree is checked and error messages are printed if a method is ill-typed.</p>
<h1 id="running-the-provided-examples">Running the provided examples</h1>
<p>To run the supplied examples, execute</p>
<pre><code>make</code></pre>
<p>at the root of the submission archive. The result should be a set of generated text files with names <code>JGSTestclasses_XXX.output.txt</code>, where <code>XXX</code> corresponds to the name of the particular example. The text files contain the output of JGS-check.</p>
<ul>
<li><strong>JGSTestclasses/ExamplesFromPaper</strong>: these are the examples from Section 2 of the paper. They should not contain type errors. Like in the paper, they contain a few commented lines that yield type-errors when uncommented.</li>
<li><strong>JGSTestclasses/ClassHierarchies</strong>: this sourcetree contains classes that exercise the class hierarchy check (cf. Sec. 4.4, Def 5). Comments on the methods describe the expected output.</li>
<li><strong>JGSTextclasses/MethodBodies</strong>: this examples contains a single class that demonstrates different aspects of method body typing. Again, comments on the methods explain the expected output.</li>
</ul>
<h2 id="jgs-annotation-and-cast-syntax">JGS Annotation and cast syntax</h2>
<p>JGS-check security properties are specified using standard Java annotations and special method calls (both of which are defined in the <code>JGSSupport</code> directory).</p>
<p>For security annotations for fields and signatures of methods are specified by the following Java Annotation classes.</p>
<ul>
<li><code>@Sec</code>: specifies the security type of a field. It takes a <strong>String</strong> as argument. Security types recognized are:
<ul>
<li><code>HIGH</code> static high-security level</li>
<li><code>LOW</code> static low-security level</li>
<li><code>?</code> the dynamic type</li>
<li><code>pub</code> the public type</li>
</ul></li>
<li><code>@Constraints</code>: specifies the constraints of a method. It takes an <strong>array of Strings</strong> as an argument. Each array element is a constraint of the form
<ul>
<li><em>constraint-element</em> <code>&lt;=</code> <em>constraint-element</em>, denoting a less-than-or-equal constraint or</li>
<li><em>constraint-element</em> <code>~</code> <em>constraint-element</em>, denoting a compatibility constraint</li>
</ul>
The constraint elements can have the form of
<ul>
<li>a security type, e.g. <code>HIGH</code></li>
<li>the return symbol <code>@ret</code></li>
<li>a parameter, <code>@0</code>, <code>@1</code>, <code>@2</code>, ... parameters are given positionally and start with index 0</li>
</ul></li>
<li><code>@Effects</code>: specifies the effects of a method. It takes an <strong>array of Strings</strong> as argument. Each element denotes a security type, e.g. <code>HIGH</code>.</li>
</ul>
<p>JGS-check recognizes special static method calls as casts. The methods are specified <code>de.unifreiburg.cs.proglang.jgs.support.Casts</code>.</p>
<ul>
<li>Value casts are identity methods of the form <code>Casts.castXxToYy</code> where <code>Xx</code> denotes the source type and <code>Yy</code> denotes the destination type of the cast.</li>
<li>Context casts start with a noop method of the form <code>Casts.castCxXxToYy</code> and end with a call to <code>Casts.castCxEnd</code>. These calls have to be properly nested.</li>
</ul>
<p>The methods in <code>JGSTestclasses/MethodBodies</code> illustrate the usage of casts.</p>
<h2 id="output-format">Output format</h2>
<p>In the output, methods and fields are specified in an unambiguous, human-readable way in between angle-bracket. For example, the field and method of the class</p>
<pre class="language-java"><code>package pkg.subpkg;
class C {
  Object anObject;
  Integer getAnInt(Object a);
}</code></pre>
<p>are represented as</p>
<pre><code>&lt;pkg.subpkg.C: java.lang.Object anObject&gt;</code></pre>
<p>and</p>
<pre><code>&lt;pkg.subpkg.C: java.lang.Integer getAnInt(java.lang.Object)&gt;</code></pre>
<p>respectively.</p>
<p>Refinement errors in the class hierarchy are displayed by</p>
<ul>
<li>listing the constraints of the super-method and the sub-method</li>
<li>providing a counterexample, that is an assignment for symbols that satisfied the super-method constraints, but not the sub-method constraints.</li>
<li>listing a subset of constraints of the sub-method that conflict with the counterexample</li>
<li>listing a set of effects that are missing from the signature of the super-method</li>
</ul>
<p>For example, for a sub-method <code>m1</code> that overrides a super-method <code>m2</code></p>
<pre class="language-java"><code>@Constraints({&quot;@0 &lt;= @ret&quot;, &quot;@1 &lt;= @ret&quot;}) 
@Effects({&quot;LOW&quot;})
int m1(int i, int j) { ... }

@Constraints({&quot;@0 &lt;= @ret&quot;}) 
int m2(int i, int j) { ... }
</code></pre>
<p>yields an error like</p>
<pre><code>super method constraints: {@0 &lt;= @ret}
sub method constraints: {@0 &lt;= @ret, @1 &lt;= @ret}
counterexample: {@0=LOW, @1=HIGH, @ret=LOW}
conflicts: {@1 &lt;= @ret}
missing effects: {LOW}</code></pre>
<p>Refinement errors in method bodies are represented similarly; the signature takes the place of the super-method while the generated constraints of the body take the place of the sub-method.</p>
<p>Unsatisfiable constraints in method bodies are reported by reconstructing the illegal information that led to them, for example</p>
<pre class="language-java"><code>class C {
 @Sec(&quot;HIGH&quot;)
 int highField;
 @Sec(&quot;LOW&quot;)
 int lowField;

 void m() {
  highField = lowField;
 }
}</code></pre>
<p>yields the message</p>
<pre><code>&lt;C : int highField&gt; (HIGH) flows into &lt;C : int lowField&gt; (LOW)</code></pre>
<h1 id="running-jgs-check-on-your-own-code">Running JGS-check on your own code</h1>
<p>To run <code>JGS-check</code> on custom sources execute the command</p>
<pre><code>java -jar GradualConstraints.jar &lt;path/to/sources&gt;</code></pre>
<p>where <code>&lt;path/to/sources&gt;</code> should point to the root of the package hierarchy for the Java sources to be checked. Alternatively, you may just modify the existing sourcetrees and use <code>make</code></p>
<h2 id="external-methods">External methods</h2>
<p>If you want to use methods or fields from the Java library, you need to specify their security signatures in the file</p>
<pre><code>JGSSupport/external-signatures.json</code></pre>
<p>It already contains some entries (e.g., for <code>Integer.valueOf</code>) that should be self-explanatory.</p>
<h2 id="usability-limitations">Usability Limitations</h2>
<p>At it's current state, the implementation has some minor limitations with respect to usability and convenience that are decribed in the following.</p>
<h2 id="parse-errors-in-constraints">Parse errors in constraints</h2>
<p>Unfortunately, the constraint parser currently does not give good error messages. Please be careful in specifying constraints.</p>
<h3 id="java.lang.string-is-broken"><code>java.lang.String</code> is broken</h3>
<p>Due to problems in the underlying analysis framework <a href="https://sable.github.io/soot/">Soot</a> checking sources that make use of <code>java.lang.String</code> often crash JGS-check. The exception thrown by Soot indicates that there is a problem parsing the <code>java.lang.CharSequence</code> classfile. The problem may be related to running Soot on a Java8 VM. We are currently underway to port JGS-check to Java7.</p>
<h3 id="auto-boxing-in-context-casts">Auto-boxing in context casts</h3>
<p>The current way of specifying context casts (using the <code>castCxXtoY</code> and <code>castCxEnd</code> methods) has problems with autoboxing which can yield false type errors. Please do not rely on auto-boxing in between context cast begin and end.</p>
<h3 id="changing-the-security-lattice-requires-recompilation">Changing the security lattice requires recompilation</h3>
<p>The security lattice is defined by classes inside <code>GradualConstraints.jar</code> and currently is not externally configurable. This limitation is however not conceptual: internally the security domain is an implementation of the <code>de.unifreiburg.cs.proglang.jgs.constraints.SecDomain</code> interface:</p>
<pre class="language-java"><code>public interface SecDomain&lt;Level&gt; {
   Level bottom(); 
   Level top();
   Level lub(Level l1, Level l2);
   Level glb(Level l1, Level l2);
   boolean le(Level l1, Level l2);

   AnnotationParser&lt;Level&gt; levelParser();

   /**
    * Optional method for enumerable domains
    * @return A stream of all the security levels.
    */
   default Stream&lt;Level&gt; enumerate() {
       throw new RuntimeException(&quot;The security domain is not enumerable.&quot;);
   }
}
</code></pre>
<p>The security domain can be switched in the source of the main class <code>de/unifreiburg/cs/proglag/jgs/JgsCheck.scala</code>. The spot is marked by the comment:</p>
<pre><code>        /****************************
         * Configuration of security lattice
         ****************************/</code></pre>
      </div>
    </div>
    <div class="footer">
          </div>
  </div>
</body>
</html>
